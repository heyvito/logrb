{"pageProps":{"item":{"type":"class","name":"Logrb","doc":{"type":"class","contents":[{"type":"text_block","contents":"Logrb provides a facility for working with logs in text and json formats.\nAll instances share a single mutex to ensure logging consistency.\nThe following attributes are available:"},{"type":"field_block","contents":{"fields":{"type":"text_block","contents":"A hash containing metadata to be included in logs emitted by this instance."},"level":{"type":"text_block","contents":[{"type":"span","contents":"The level filter for the instance. Valid values are "},{"type":"sym_ref","contents":":error"},{"type":"span","contents":", "},{"type":"sym_ref","contents":":fatal"},{"type":"span","contents":", "},{"type":"sym_ref","contents":":info"},{"type":"span","contents":", "},{"type":"sym_ref","contents":":warn"},{"type":"span","contents":", and "},{"type":"sym_ref","contents":":debug"}]},"format":{"type":"text_block","contents":[{"type":"span","contents":"The format to output logs. Supports "},{"type":"sym_ref","contents":":text"},{"type":"span","contents":" and "},{"type":"sym_ref","contents":":json"},{"type":"span","contents":"."}]}}},{"type":"text_block","contents":"Each instance exposes the following methods, which accepts an arbitrary\nnumber of key-value pairs to be included in the logged message:"},{"type":"text_block","contents":[{"type":"ref","ref_type":"method","name":"error","target":null,"class_path":null,"contents":"#error(msg, error=nil, **fields)","ref_path":["Logrb","error"]},{"type":"span","contents":": Outputs an error entry. When <code>error</code> is present, attempts to obtain backtrace information and also includes it to the emitted entry."}]},{"type":"text_block","contents":[{"type":"ref","ref_type":"method","name":"fatal","target":null,"class_path":null,"contents":"#fatal(msg, **fields)","ref_path":["Logrb","fatal"]},{"type":"span","contents":": Outputs a fatal entry. Calling fatal causes the current process to exit with a status 1."}]},{"type":"text_block","contents":[{"type":"ref","ref_type":"method","name":"warn","target":null,"class_path":null,"contents":"#warn(msg, **fields)"},{"type":"span","contents":": Outputs a warning entry."}]},{"type":"text_block","contents":[{"type":"ref","ref_type":"method","name":"info","target":null,"class_path":null,"contents":"#info(msg, **fields)"},{"type":"span","contents":": Outputs a informational entry."}]},{"type":"text_block","contents":[{"type":"ref","ref_type":"method","name":"debug","target":null,"class_path":null,"contents":"#debug(msg, **fields)"},{"type":"span","contents":": Outputs a debug entry."}]},{"type":"text_block","contents":[{"type":"ref","ref_type":"method","name":"dump","target":null,"class_path":null,"contents":"#dump(msg, data=nil)","ref_path":["Logrb","dump"]},{"type":"span","contents":": Outputs a given String or Array of bytes using the same format as <code>hexdump -C</code>."}]}]},"defined_by":[{"filename":"/work/lib/logrb.rb","start_at":35,"end_at":289,"source":"class Logrb\n  attr_accessor :fields, :level, :format\n\n  COLORS = {\n    error: 31,\n    fatal: 31,\n    unknown: 0,\n    info: 36,\n    warn: 33,\n    debug: 30,\n    reset: 0,\n    dump: 37\n  }.freeze\n\n  BACKGROUNDS = {\n    debug: 107\n  }.freeze\n\n  LEVELS = {\n    error: 4,\n    fatal: 4,\n    unknown: 4,\n    warn: 3,\n    info: 2,\n    debug: 1,\n    reset: 1\n  }.freeze\n\n  # Internal: A mutex instance used for synchronizing the usage of the output\n  # IO.\n  def self.mutex\n    @mutex ||= Mutex.new\n  end\n\n  # Initializes a new Logger instance that outputs logs to a provided output.\n  #\n  # output - an IO-like object that implements a #write method.\n  # format - Optional. Indicates the format used to output log entries.\n  #          Supports :text (default) and :json.\n  # level  - Level to filter this logger instance\n  # fields - Fields to include in emitted entries\n  def initialize(output, format: :text, level: :debug, **fields)\n    @output = output\n    @format = format\n    @fields = fields\n    @level = level\n  end\n\n  # Returns a new logger instance using the same output of its parent's, with\n  # an optional set of fields to be merged against the parent's fields.\n  #\n  # fields - A Hash containing metadata to be included in all output entries\n  #          emitted from the returned instance.\n  def with_fields(**fields)\n    inst = Logrb.new(@output, format: @format, level: @level)\n    inst.fields = @fields.merge(fields)\n    inst\n  end\n\n  LEVELS.except(:error, :fatal).each_key do |name|\n    define_method(name) do |msg, **fields|\n      return if LEVELS[@level] > LEVELS[name]\n\n      wrap(name, msg, nil, fields)\n      nil\n    end\n  end\n\n  # Public: Emits an error to the log output. When error is provided, this\n  # method attempts to gather a stacktrace to include in the emitted entry.\n  def error(msg, error = nil, **fields)\n    return if LEVELS[@level] > LEVELS[:error]\n\n    wrap(:error, msg, error, fields)\n    nil\n  end\n\n  # Public: Emits a fatal message to the log output, and invokes Kernel#exit\n  # with a non-zero status code. When error is provided, this method attempts\n  # to gather a stacktrace to include in the emitted entry. This log entry\n  # cannot be filtered, and is always emitted.\n  def fatal(msg, error = nil, **fields)\n    wrap(:fatal, msg, error, fields)\n    exit 1\n  end\n\n  # Public: Dumps a given String or Array in the same format as `hexdump -C`.\n  def dump(log, data = nil, **fields)\n    return if LEVELS[@level] > LEVELS[:debug]\n\n    if data.nil?\n      data = log\n      log = nil\n    end\n\n    data = data.pack(\"C*\") if data.is_a? Array\n    dump = []\n    padding = @format == :json ? \"\" : \"        \"\n    Hexdump.dump(data, output: dump)\n    dump.map! { |line| \"#{padding}#{line.chomp}\" }\n    dump = dump.join(\"\\n\")\n\n    if @format == :json\n      fields[:dump] = dump\n      dump = nil\n    end\n    wrap(:dump, log || \"\", nil, fields)\n    write_output(\"#{dump}\\n\\n\") unless dump.nil?\n  end\n\n  private\n\n  # Internal: Formats a given text using the ANSI escape sequences. Notice\n  # that this method does not attempt to determine whether the current output\n  # supports escape sequences.\n  def color(color, text)\n    bg = BACKGROUNDS[color]\n    reset_bg = \"\"\n    if bg\n      bg = \"\\e[#{bg}m\"\n      reset_bg = \"\\e[49m\"\n    end\n    \"#{bg}\\e[#{COLORS[color]}m#{text}\\e[#{COLORS[:reset]}m#{reset_bg}\"\n  end\n\n  # Internal: Removes all backtrace frames pointing to the logging facility\n  # itself.\n  def clean_caller_locations\n    caller_locations.reject { |t| t.absolute_path&.end_with?(\"logrb.rb\") }\n  end\n\n  # Internal: Returns the caller of a function, returning a pair containing\n  # its path and base method name.\n  def determine_caller\n    c = clean_caller_locations.first\n    [normalize_location(c), c.base_label]\n  end\n\n  # Internal: Performs a cleanup for a given backtrace frame.\n  #\n  # trace                 - Trace to be clean.\n  # include_function_name - Optional. When true, includes the function name\n  #                         on the normalized string. Defaults to false.\n  def normalize_location(trace, include_function_name: false)\n    path = trace.absolute_path\n    return trace.to_s if path.nil?\n\n    if (root = Gem.path.find { |p| path.start_with?(p) })\n      path = \"$GEM_PATH#{path[root.length..]}\"\n    end\n    \"#{path}:#{trace.lineno}#{include_function_name ? \" in `#{trace.label}'\" : \"\"}\"\n  end\n\n  # Internal: Returns a string containing a stacktrace of the current\n  # invocation.\n  def stack_trace(trace = clean_caller_locations)\n    trace.map { |s| normalize_location(s, include_function_name: true) }.join(\"\\n\")\n  end\n\n  # Internal: Composes a log line with given information.\n  #\n  # level       - The severity of the log message\n  # caller_meta - An Array containing the caller's location and name\n  # msg         - The message to be logged\n  # fields      - A Hash of fields to be included in the entry\n  def compose_line(level, caller_meta, msg, fields)\n    ts = Time.now.strftime(\"%Y-%m-%dT%H:%M:%S.%L%z\")\n    msg = \" #{msg}\" unless msg.empty?\n    fields_str = if fields.empty?\n                   \"\"\n                 else\n                   \" #{fields}\"\n                 end\n    level_str = color(level, level.to_s.upcase)\n    \"#{ts} #{level_str}: #{caller_meta.last}:#{msg}#{fields_str}\"\n  end\n\n  # Internal: Logs a text entry to the current output.\n  #\n  # level       - The severity of the message to be logged.\n  # msg         - The message to be logged\n  # error       - Either an Exception object or nil. This parameter is used\n  #               to provide extra information on the logged entry.\n  # fields      - A Hash containing metadata to be included in the logged\n  #               entry.\n  # caller_meta - An Array containing the caller's location and name.\n  def text(level, msg, error, fields, caller_meta)\n    fields ||= {}\n    fields.merge! @fields\n    write_output(compose_line(level, caller_meta, msg, fields))\n    if (error_message = error&.message)\n      write_output(\": #{error_message}\")\n    end\n    write_output(\"\\n\")\n    return unless level == :error\n\n    backtrace_str = backtrace(error)\n                    .split(\"\\n\")\n                    .map { |s| \"        #{s}\" }.join(\"\\n\")\n    write_output(backtrace_str)\n    write_output(\"\\n\")\n  end\n\n  # Internal: Attempts to obtain a backtrace from a provided object. In case\n  # the object does not include backtrace metadata, uses #stack_trace as a\n  # fallback.\n  def backtrace(from)\n    if from.respond_to?(:backtrace_locations) && !from.backtrace_locations.nil?\n      stack_trace(from.backtrace_locations)\n    else\n      stack_trace\n    end\n  end\n\n  # Internal: Writes a given value to the current's output IO. Calls to this\n  # method are thread-safe.\n  def write_output(text)\n    Logrb.mutex.synchronize do\n      @output.write(text)\n    end\n  end\n\n  # Internal: Logs a JSON entry to the current output.\n  #\n  # level       - The severity of the message to be logged.\n  # msg         - The message to be logged\n  # error       - Either an Exception object or nil. This parameter is used\n  #               to provide extra information on the logged entry.\n  # fields      - A Hash containing metadata to be included in the logged\n  #               entry.\n  # caller_meta - An Array containing the caller's location and name.\n  def json(level, msg, error, fields, caller_meta)\n    fields ||= {}\n    fields.merge! @fields\n    data = {\n      level: level,\n      caller: caller_meta.first,\n      msg: msg,\n      ts: Time.now.utc.to_i\n    }\n\n    data[:stacktrace] = backtrace(error) if level == :error\n\n    data.merge!(fields)\n    write_output(\"#{data.to_json}\\n\")\n  end\n\n  # Internal: Dynamically invokes the current log formatter for the\n  # provided arguments. For further information, see #text and #json\n  def wrap(level, msg, error, fields)\n    msg = msg.to_s\n    send(@format, level, msg, error, fields, determine_caller)\n    exit 1 if level == :fatal\n  end\nend","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">Logrb</span>\n  <span class=\"nb\">attr_accessor</span> <span class=\"ss\">:fields</span><span class=\"p\">,</span> <span class=\"ss\">:level</span><span class=\"p\">,</span> <span class=\"ss\">:format</span>\n\n  <span class=\"no\">COLORS</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"ss\">error: </span><span class=\"mi\">31</span><span class=\"p\">,</span>\n    <span class=\"ss\">fatal: </span><span class=\"mi\">31</span><span class=\"p\">,</span>\n    <span class=\"ss\">unknown: </span><span class=\"mi\">0</span><span class=\"p\">,</span>\n    <span class=\"ss\">info: </span><span class=\"mi\">36</span><span class=\"p\">,</span>\n    <span class=\"ss\">warn: </span><span class=\"mi\">33</span><span class=\"p\">,</span>\n    <span class=\"ss\">debug: </span><span class=\"mi\">30</span><span class=\"p\">,</span>\n    <span class=\"ss\">reset: </span><span class=\"mi\">0</span><span class=\"p\">,</span>\n    <span class=\"ss\">dump: </span><span class=\"mi\">37</span>\n  <span class=\"p\">}.</span><span class=\"nf\">freeze</span>\n\n  <span class=\"no\">BACKGROUNDS</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"ss\">debug: </span><span class=\"mi\">107</span>\n  <span class=\"p\">}.</span><span class=\"nf\">freeze</span>\n\n  <span class=\"no\">LEVELS</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"ss\">error: </span><span class=\"mi\">4</span><span class=\"p\">,</span>\n    <span class=\"ss\">fatal: </span><span class=\"mi\">4</span><span class=\"p\">,</span>\n    <span class=\"ss\">unknown: </span><span class=\"mi\">4</span><span class=\"p\">,</span>\n    <span class=\"ss\">warn: </span><span class=\"mi\">3</span><span class=\"p\">,</span>\n    <span class=\"ss\">info: </span><span class=\"mi\">2</span><span class=\"p\">,</span>\n    <span class=\"ss\">debug: </span><span class=\"mi\">1</span><span class=\"p\">,</span>\n    <span class=\"ss\">reset: </span><span class=\"mi\">1</span>\n  <span class=\"p\">}.</span><span class=\"nf\">freeze</span>\n\n  <span class=\"c1\"># Internal: A mutex instance used for synchronizing the usage of the output</span>\n  <span class=\"c1\"># IO.</span>\n  <span class=\"k\">def</span> <span class=\"nc\">self</span><span class=\"o\">.</span><span class=\"nf\">mutex</span>\n    <span class=\"vi\">@mutex</span> <span class=\"o\">||=</span> <span class=\"no\">Mutex</span><span class=\"p\">.</span><span class=\"nf\">new</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Initializes a new Logger instance that outputs logs to a provided output.</span>\n  <span class=\"c1\">#</span>\n  <span class=\"c1\"># output - an IO-like object that implements a #write method.</span>\n  <span class=\"c1\"># format - Optional. Indicates the format used to output log entries.</span>\n  <span class=\"c1\">#          Supports :text (default) and :json.</span>\n  <span class=\"c1\"># level  - Level to filter this logger instance</span>\n  <span class=\"c1\"># fields - Fields to include in emitted entries</span>\n  <span class=\"k\">def</span> <span class=\"nf\">initialize</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">,</span> <span class=\"ss\">format: :text</span><span class=\"p\">,</span> <span class=\"ss\">level: :debug</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"vi\">@output</span> <span class=\"o\">=</span> <span class=\"n\">output</span>\n    <span class=\"vi\">@format</span> <span class=\"o\">=</span> <span class=\"nb\">format</span>\n    <span class=\"vi\">@fields</span> <span class=\"o\">=</span> <span class=\"n\">fields</span>\n    <span class=\"vi\">@level</span> <span class=\"o\">=</span> <span class=\"n\">level</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Returns a new logger instance using the same output of its parent's, with</span>\n  <span class=\"c1\"># an optional set of fields to be merged against the parent's fields.</span>\n  <span class=\"c1\">#</span>\n  <span class=\"c1\"># fields - A Hash containing metadata to be included in all output entries</span>\n  <span class=\"c1\">#          emitted from the returned instance.</span>\n  <span class=\"k\">def</span> <span class=\"nf\">with_fields</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">inst</span> <span class=\"o\">=</span> <span class=\"no\">Logrb</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"vi\">@output</span><span class=\"p\">,</span> <span class=\"ss\">format: </span><span class=\"vi\">@format</span><span class=\"p\">,</span> <span class=\"ss\">level: </span><span class=\"vi\">@level</span><span class=\"p\">)</span>\n    <span class=\"n\">inst</span><span class=\"p\">.</span><span class=\"nf\">fields</span> <span class=\"o\">=</span> <span class=\"vi\">@fields</span><span class=\"p\">.</span><span class=\"nf\">merge</span><span class=\"p\">(</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">inst</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"no\">LEVELS</span><span class=\"p\">.</span><span class=\"nf\">except</span><span class=\"p\">(</span><span class=\"ss\">:error</span><span class=\"p\">,</span> <span class=\"ss\">:fatal</span><span class=\"p\">).</span><span class=\"nf\">each_key</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"nb\">name</span><span class=\"o\">|</span>\n    <span class=\"n\">define_method</span><span class=\"p\">(</span><span class=\"nb\">name</span><span class=\"p\">)</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">fields</span><span class=\"o\">|</span>\n      <span class=\"k\">return</span> <span class=\"k\">if</span> <span class=\"no\">LEVELS</span><span class=\"p\">[</span><span class=\"vi\">@level</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"no\">LEVELS</span><span class=\"p\">[</span><span class=\"nb\">name</span><span class=\"p\">]</span>\n\n      <span class=\"n\">wrap</span><span class=\"p\">(</span><span class=\"nb\">name</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"kp\">nil</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span>\n      <span class=\"kp\">nil</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Public: Emits an error to the log output. When error is provided, this</span>\n  <span class=\"c1\"># method attempts to gather a stacktrace to include in the emitted entry.</span>\n  <span class=\"k\">def</span> <span class=\"nf\">error</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"kp\">nil</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"k\">if</span> <span class=\"no\">LEVELS</span><span class=\"p\">[</span><span class=\"vi\">@level</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"no\">LEVELS</span><span class=\"p\">[</span><span class=\"ss\">:error</span><span class=\"p\">]</span>\n\n    <span class=\"n\">wrap</span><span class=\"p\">(</span><span class=\"ss\">:error</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"kp\">nil</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Public: Emits a fatal message to the log output, and invokes Kernel#exit</span>\n  <span class=\"c1\"># with a non-zero status code. When error is provided, this method attempts</span>\n  <span class=\"c1\"># to gather a stacktrace to include in the emitted entry. This log entry</span>\n  <span class=\"c1\"># cannot be filtered, and is always emitted.</span>\n  <span class=\"k\">def</span> <span class=\"nf\">fatal</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"kp\">nil</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">wrap</span><span class=\"p\">(</span><span class=\"ss\">:fatal</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"nb\">exit</span> <span class=\"mi\">1</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Public: Dumps a given String or Array in the same format as `hexdump -C`.</span>\n  <span class=\"k\">def</span> <span class=\"nf\">dump</span><span class=\"p\">(</span><span class=\"n\">log</span><span class=\"p\">,</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"kp\">nil</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"k\">if</span> <span class=\"no\">LEVELS</span><span class=\"p\">[</span><span class=\"vi\">@level</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"no\">LEVELS</span><span class=\"p\">[</span><span class=\"ss\">:debug</span><span class=\"p\">]</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">data</span><span class=\"p\">.</span><span class=\"nf\">nil?</span>\n      <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">log</span>\n      <span class=\"n\">log</span> <span class=\"o\">=</span> <span class=\"kp\">nil</span>\n    <span class=\"k\">end</span>\n\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"p\">.</span><span class=\"nf\">pack</span><span class=\"p\">(</span><span class=\"s2\">\"C*\"</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">data</span><span class=\"p\">.</span><span class=\"nf\">is_a?</span> <span class=\"no\">Array</span>\n    <span class=\"n\">dump</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"n\">padding</span> <span class=\"o\">=</span> <span class=\"vi\">@format</span> <span class=\"o\">==</span> <span class=\"ss\">:json</span> <span class=\"p\">?</span> <span class=\"s2\">\"\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"        \"</span>\n    <span class=\"no\">Hexdump</span><span class=\"p\">.</span><span class=\"nf\">dump</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"ss\">output: </span><span class=\"n\">dump</span><span class=\"p\">)</span>\n    <span class=\"n\">dump</span><span class=\"p\">.</span><span class=\"nf\">map!</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">line</span><span class=\"o\">|</span> <span class=\"s2\">\"</span><span class=\"si\">#{</span><span class=\"n\">padding</span><span class=\"si\">}#{</span><span class=\"n\">line</span><span class=\"p\">.</span><span class=\"nf\">chomp</span><span class=\"si\">}</span><span class=\"s2\">\"</span> <span class=\"p\">}</span>\n    <span class=\"n\">dump</span> <span class=\"o\">=</span> <span class=\"n\">dump</span><span class=\"p\">.</span><span class=\"nf\">join</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"vi\">@format</span> <span class=\"o\">==</span> <span class=\"ss\">:json</span>\n      <span class=\"n\">fields</span><span class=\"p\">[</span><span class=\"ss\">:dump</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">dump</span>\n      <span class=\"n\">dump</span> <span class=\"o\">=</span> <span class=\"kp\">nil</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">wrap</span><span class=\"p\">(</span><span class=\"ss\">:dump</span><span class=\"p\">,</span> <span class=\"n\">log</span> <span class=\"o\">||</span> <span class=\"s2\">\"\"</span><span class=\"p\">,</span> <span class=\"kp\">nil</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"si\">#{</span><span class=\"n\">dump</span><span class=\"si\">}</span><span class=\"se\">\\n\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span> <span class=\"k\">unless</span> <span class=\"n\">dump</span><span class=\"p\">.</span><span class=\"nf\">nil?</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"kp\">private</span>\n\n  <span class=\"c1\"># Internal: Formats a given text using the ANSI escape sequences. Notice</span>\n  <span class=\"c1\"># that this method does not attempt to determine whether the current output</span>\n  <span class=\"c1\"># supports escape sequences.</span>\n  <span class=\"k\">def</span> <span class=\"nf\">color</span><span class=\"p\">(</span><span class=\"n\">color</span><span class=\"p\">,</span> <span class=\"n\">text</span><span class=\"p\">)</span>\n    <span class=\"n\">bg</span> <span class=\"o\">=</span> <span class=\"no\">BACKGROUNDS</span><span class=\"p\">[</span><span class=\"n\">color</span><span class=\"p\">]</span>\n    <span class=\"n\">reset_bg</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"</span>\n    <span class=\"k\">if</span> <span class=\"n\">bg</span>\n      <span class=\"n\">bg</span> <span class=\"o\">=</span> <span class=\"s2\">\"</span><span class=\"se\">\\e</span><span class=\"s2\">[</span><span class=\"si\">#{</span><span class=\"n\">bg</span><span class=\"si\">}</span><span class=\"s2\">m\"</span>\n      <span class=\"n\">reset_bg</span> <span class=\"o\">=</span> <span class=\"s2\">\"</span><span class=\"se\">\\e</span><span class=\"s2\">[49m\"</span>\n    <span class=\"k\">end</span>\n    <span class=\"s2\">\"</span><span class=\"si\">#{</span><span class=\"n\">bg</span><span class=\"si\">}</span><span class=\"se\">\\e</span><span class=\"s2\">[</span><span class=\"si\">#{</span><span class=\"no\">COLORS</span><span class=\"p\">[</span><span class=\"n\">color</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s2\">m</span><span class=\"si\">#{</span><span class=\"n\">text</span><span class=\"si\">}</span><span class=\"se\">\\e</span><span class=\"s2\">[</span><span class=\"si\">#{</span><span class=\"no\">COLORS</span><span class=\"p\">[</span><span class=\"ss\">:reset</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s2\">m</span><span class=\"si\">#{</span><span class=\"n\">reset_bg</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Internal: Removes all backtrace frames pointing to the logging facility</span>\n  <span class=\"c1\"># itself.</span>\n  <span class=\"k\">def</span> <span class=\"nf\">clean_caller_locations</span>\n    <span class=\"n\">caller_locations</span><span class=\"p\">.</span><span class=\"nf\">reject</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">t</span><span class=\"o\">|</span> <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">absolute_path</span><span class=\"o\">&amp;</span><span class=\"p\">.</span><span class=\"nf\">end_with?</span><span class=\"p\">(</span><span class=\"s2\">\"logrb.rb\"</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Internal: Returns the caller of a function, returning a pair containing</span>\n  <span class=\"c1\"># its path and base method name.</span>\n  <span class=\"k\">def</span> <span class=\"nf\">determine_caller</span>\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">clean_caller_locations</span><span class=\"p\">.</span><span class=\"nf\">first</span>\n    <span class=\"p\">[</span><span class=\"n\">normalize_location</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">),</span> <span class=\"n\">c</span><span class=\"p\">.</span><span class=\"nf\">base_label</span><span class=\"p\">]</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Internal: Performs a cleanup for a given backtrace frame.</span>\n  <span class=\"c1\">#</span>\n  <span class=\"c1\"># trace                 - Trace to be clean.</span>\n  <span class=\"c1\"># include_function_name - Optional. When true, includes the function name</span>\n  <span class=\"c1\">#                         on the normalized string. Defaults to false.</span>\n  <span class=\"k\">def</span> <span class=\"nf\">normalize_location</span><span class=\"p\">(</span><span class=\"n\">trace</span><span class=\"p\">,</span> <span class=\"ss\">include_function_name: </span><span class=\"kp\">false</span><span class=\"p\">)</span>\n    <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"n\">trace</span><span class=\"p\">.</span><span class=\"nf\">absolute_path</span>\n    <span class=\"k\">return</span> <span class=\"n\">trace</span><span class=\"p\">.</span><span class=\"nf\">to_s</span> <span class=\"k\">if</span> <span class=\"n\">path</span><span class=\"p\">.</span><span class=\"nf\">nil?</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"no\">Gem</span><span class=\"p\">.</span><span class=\"nf\">path</span><span class=\"p\">.</span><span class=\"nf\">find</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"nb\">p</span><span class=\"o\">|</span> <span class=\"n\">path</span><span class=\"p\">.</span><span class=\"nf\">start_with?</span><span class=\"p\">(</span><span class=\"nb\">p</span><span class=\"p\">)</span> <span class=\"p\">})</span>\n      <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"s2\">\"$GEM_PATH</span><span class=\"si\">#{</span><span class=\"n\">path</span><span class=\"p\">[</span><span class=\"n\">root</span><span class=\"p\">.</span><span class=\"nf\">length</span><span class=\"o\">..</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n    <span class=\"k\">end</span>\n    <span class=\"s2\">\"</span><span class=\"si\">#{</span><span class=\"n\">path</span><span class=\"si\">}</span><span class=\"s2\">:</span><span class=\"si\">#{</span><span class=\"n\">trace</span><span class=\"p\">.</span><span class=\"nf\">lineno</span><span class=\"si\">}#{</span><span class=\"n\">include_function_name</span> <span class=\"p\">?</span> <span class=\"s2\">\" in `</span><span class=\"si\">#{</span><span class=\"n\">trace</span><span class=\"p\">.</span><span class=\"nf\">label</span><span class=\"si\">}</span><span class=\"s2\">'\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"\"</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Internal: Returns a string containing a stacktrace of the current</span>\n  <span class=\"c1\"># invocation.</span>\n  <span class=\"k\">def</span> <span class=\"nf\">stack_trace</span><span class=\"p\">(</span><span class=\"n\">trace</span> <span class=\"o\">=</span> <span class=\"n\">clean_caller_locations</span><span class=\"p\">)</span>\n    <span class=\"n\">trace</span><span class=\"p\">.</span><span class=\"nf\">map</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">s</span><span class=\"o\">|</span> <span class=\"n\">normalize_location</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"ss\">include_function_name: </span><span class=\"kp\">true</span><span class=\"p\">)</span> <span class=\"p\">}.</span><span class=\"nf\">join</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Internal: Composes a log line with given information.</span>\n  <span class=\"c1\">#</span>\n  <span class=\"c1\"># level       - The severity of the log message</span>\n  <span class=\"c1\"># caller_meta - An Array containing the caller's location and name</span>\n  <span class=\"c1\"># msg         - The message to be logged</span>\n  <span class=\"c1\"># fields      - A Hash of fields to be included in the entry</span>\n  <span class=\"k\">def</span> <span class=\"nf\">compose_line</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">caller_meta</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">ts</span> <span class=\"o\">=</span> <span class=\"no\">Time</span><span class=\"p\">.</span><span class=\"nf\">now</span><span class=\"p\">.</span><span class=\"nf\">strftime</span><span class=\"p\">(</span><span class=\"s2\">\"%Y-%m-%dT%H:%M:%S.%L%z\"</span><span class=\"p\">)</span>\n    <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">\" </span><span class=\"si\">#{</span><span class=\"n\">msg</span><span class=\"si\">}</span><span class=\"s2\">\"</span> <span class=\"k\">unless</span> <span class=\"n\">msg</span><span class=\"p\">.</span><span class=\"nf\">empty?</span>\n    <span class=\"n\">fields_str</span> <span class=\"o\">=</span> <span class=\"k\">if</span> <span class=\"n\">fields</span><span class=\"p\">.</span><span class=\"nf\">empty?</span>\n                   <span class=\"s2\">\"\"</span>\n                 <span class=\"k\">else</span>\n                   <span class=\"s2\">\" </span><span class=\"si\">#{</span><span class=\"n\">fields</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n                 <span class=\"k\">end</span>\n    <span class=\"n\">level_str</span> <span class=\"o\">=</span> <span class=\"n\">color</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">level</span><span class=\"p\">.</span><span class=\"nf\">to_s</span><span class=\"p\">.</span><span class=\"nf\">upcase</span><span class=\"p\">)</span>\n    <span class=\"s2\">\"</span><span class=\"si\">#{</span><span class=\"n\">ts</span><span class=\"si\">}</span><span class=\"s2\"> </span><span class=\"si\">#{</span><span class=\"n\">level_str</span><span class=\"si\">}</span><span class=\"s2\">: </span><span class=\"si\">#{</span><span class=\"n\">caller_meta</span><span class=\"p\">.</span><span class=\"nf\">last</span><span class=\"si\">}</span><span class=\"s2\">:</span><span class=\"si\">#{</span><span class=\"n\">msg</span><span class=\"si\">}#{</span><span class=\"n\">fields_str</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Internal: Logs a text entry to the current output.</span>\n  <span class=\"c1\">#</span>\n  <span class=\"c1\"># level       - The severity of the message to be logged.</span>\n  <span class=\"c1\"># msg         - The message to be logged</span>\n  <span class=\"c1\"># error       - Either an Exception object or nil. This parameter is used</span>\n  <span class=\"c1\">#               to provide extra information on the logged entry.</span>\n  <span class=\"c1\"># fields      - A Hash containing metadata to be included in the logged</span>\n  <span class=\"c1\">#               entry.</span>\n  <span class=\"c1\"># caller_meta - An Array containing the caller's location and name.</span>\n  <span class=\"k\">def</span> <span class=\"nf\">text</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">,</span> <span class=\"n\">caller_meta</span><span class=\"p\">)</span>\n    <span class=\"n\">fields</span> <span class=\"o\">||=</span> <span class=\"p\">{}</span>\n    <span class=\"n\">fields</span><span class=\"p\">.</span><span class=\"nf\">merge!</span> <span class=\"vi\">@fields</span>\n    <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"n\">compose_line</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">caller_meta</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">))</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">error_message</span> <span class=\"o\">=</span> <span class=\"n\">error</span><span class=\"o\">&amp;</span><span class=\"p\">.</span><span class=\"nf\">message</span><span class=\"p\">)</span>\n      <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"s2\">\": </span><span class=\"si\">#{</span><span class=\"n\">error_message</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"k\">unless</span> <span class=\"n\">level</span> <span class=\"o\">==</span> <span class=\"ss\">:error</span>\n\n    <span class=\"n\">backtrace_str</span> <span class=\"o\">=</span> <span class=\"n\">backtrace</span><span class=\"p\">(</span><span class=\"n\">error</span><span class=\"p\">)</span>\n                    <span class=\"p\">.</span><span class=\"nf\">split</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n                    <span class=\"p\">.</span><span class=\"nf\">map</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">s</span><span class=\"o\">|</span> <span class=\"s2\">\"        </span><span class=\"si\">#{</span><span class=\"n\">s</span><span class=\"si\">}</span><span class=\"s2\">\"</span> <span class=\"p\">}.</span><span class=\"nf\">join</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"n\">backtrace_str</span><span class=\"p\">)</span>\n    <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Internal: Attempts to obtain a backtrace from a provided object. In case</span>\n  <span class=\"c1\"># the object does not include backtrace metadata, uses #stack_trace as a</span>\n  <span class=\"c1\"># fallback.</span>\n  <span class=\"k\">def</span> <span class=\"nf\">backtrace</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">from</span><span class=\"p\">.</span><span class=\"nf\">respond_to?</span><span class=\"p\">(</span><span class=\"ss\">:backtrace_locations</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">from</span><span class=\"p\">.</span><span class=\"nf\">backtrace_locations</span><span class=\"p\">.</span><span class=\"nf\">nil?</span>\n      <span class=\"n\">stack_trace</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">.</span><span class=\"nf\">backtrace_locations</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">stack_trace</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Internal: Writes a given value to the current's output IO. Calls to this</span>\n  <span class=\"c1\"># method are thread-safe.</span>\n  <span class=\"k\">def</span> <span class=\"nf\">write_output</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n    <span class=\"no\">Logrb</span><span class=\"p\">.</span><span class=\"nf\">mutex</span><span class=\"p\">.</span><span class=\"nf\">synchronize</span> <span class=\"k\">do</span>\n      <span class=\"vi\">@output</span><span class=\"p\">.</span><span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Internal: Logs a JSON entry to the current output.</span>\n  <span class=\"c1\">#</span>\n  <span class=\"c1\"># level       - The severity of the message to be logged.</span>\n  <span class=\"c1\"># msg         - The message to be logged</span>\n  <span class=\"c1\"># error       - Either an Exception object or nil. This parameter is used</span>\n  <span class=\"c1\">#               to provide extra information on the logged entry.</span>\n  <span class=\"c1\"># fields      - A Hash containing metadata to be included in the logged</span>\n  <span class=\"c1\">#               entry.</span>\n  <span class=\"c1\"># caller_meta - An Array containing the caller's location and name.</span>\n  <span class=\"k\">def</span> <span class=\"nf\">json</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">,</span> <span class=\"n\">caller_meta</span><span class=\"p\">)</span>\n    <span class=\"n\">fields</span> <span class=\"o\">||=</span> <span class=\"p\">{}</span>\n    <span class=\"n\">fields</span><span class=\"p\">.</span><span class=\"nf\">merge!</span> <span class=\"vi\">@fields</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n      <span class=\"ss\">level: </span><span class=\"n\">level</span><span class=\"p\">,</span>\n      <span class=\"ss\">caller: </span><span class=\"n\">caller_meta</span><span class=\"p\">.</span><span class=\"nf\">first</span><span class=\"p\">,</span>\n      <span class=\"ss\">msg: </span><span class=\"n\">msg</span><span class=\"p\">,</span>\n      <span class=\"ss\">ts: </span><span class=\"no\">Time</span><span class=\"p\">.</span><span class=\"nf\">now</span><span class=\"p\">.</span><span class=\"nf\">utc</span><span class=\"p\">.</span><span class=\"nf\">to_i</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"ss\">:stacktrace</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">backtrace</span><span class=\"p\">(</span><span class=\"n\">error</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">level</span> <span class=\"o\">==</span> <span class=\"ss\">:error</span>\n\n    <span class=\"n\">data</span><span class=\"p\">.</span><span class=\"nf\">merge!</span><span class=\"p\">(</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"si\">#{</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"nf\">to_json</span><span class=\"si\">}</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"c1\"># Internal: Dynamically invokes the current log formatter for the</span>\n  <span class=\"c1\"># provided arguments. For further information, see #text and #json</span>\n  <span class=\"k\">def</span> <span class=\"nf\">wrap</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"n\">msg</span><span class=\"p\">.</span><span class=\"nf\">to_s</span>\n    <span class=\"nb\">send</span><span class=\"p\">(</span><span class=\"vi\">@format</span><span class=\"p\">,</span> <span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">,</span> <span class=\"n\">determine_caller</span><span class=\"p\">)</span>\n    <span class=\"nb\">exit</span> <span class=\"mi\">1</span> <span class=\"k\">if</span> <span class=\"n\">level</span> <span class=\"o\">==</span> <span class=\"ss\">:fatal</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>"}],"defs":{"initialize":{"source":"source","definition":{"type":"def","name":"initialize","args":[{"type":"arg","name":"output"},{"type":"kwoptarg","name":"format","value_type":"sym","value":"text"},{"type":"kwoptarg","name":"level","value_type":"sym","value":"debug"},{"type":"kwrestarg","name":"fields"}],"doc":{"type":"def","contents":[{"type":"text_block","contents":"Initializes a new Logger instance that outputs logs to a provided output."},{"type":"field_block","contents":{"output":{"type":"text_block","contents":[{"type":"span","contents":"an IO-like object that implements a "},{"type":"ref","ref_type":"method","name":"write","target":null,"class_path":null,"contents":"#write"},{"type":"span","contents":" method."}]},"format":{"type":"text_block","contents":[{"type":"span","contents":"Optional. Indicates the format used to output log entries. Supports "},{"type":"sym_ref","contents":":text"},{"type":"span","contents":" (default) and "},{"type":"sym_ref","contents":":json"},{"type":"span","contents":"."}]},"level":{"type":"text_block","contents":"Level to filter this logger instance"},"fields":{"type":"text_block","contents":"Fields to include in emitted entries"}}}]},"visibility":"public","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":76,"end_at":81,"source":"  def initialize(output, format: :text, level: :debug, **fields)\n    @output = output\n    @format = format\n    @fields = fields\n    @level = level\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">initialize</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">,</span> <span class=\"ss\">format: :text</span><span class=\"p\">,</span> <span class=\"ss\">level: :debug</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"vi\">@output</span> <span class=\"o\">=</span> <span class=\"n\">output</span>\n    <span class=\"vi\">@format</span> <span class=\"o\">=</span> <span class=\"nb\">format</span>\n    <span class=\"vi\">@fields</span> <span class=\"o\">=</span> <span class=\"n\">fields</span>\n    <span class=\"vi\">@level</span> <span class=\"o\">=</span> <span class=\"n\">level</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"with_fields":{"source":"source","definition":{"type":"def","name":"with_fields","args":[{"type":"kwrestarg","name":"fields"}],"doc":{"type":"def","contents":[{"type":"text_block","contents":"Returns a new logger instance using the same output of its parent&#39;s, with\nan optional set of fields to be merged against the parent&#39;s fields."},{"type":"field_block","contents":{"fields":{"type":"text_block","contents":"A Hash containing metadata to be included in all output entries emitted from the returned instance."}}}]},"visibility":"public","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":88,"end_at":92,"source":"  def with_fields(**fields)\n    inst = Logrb.new(@output, format: @format, level: @level)\n    inst.fields = @fields.merge(fields)\n    inst\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">with_fields</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">inst</span> <span class=\"o\">=</span> <span class=\"no\">Logrb</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"vi\">@output</span><span class=\"p\">,</span> <span class=\"ss\">format: </span><span class=\"vi\">@format</span><span class=\"p\">,</span> <span class=\"ss\">level: </span><span class=\"vi\">@level</span><span class=\"p\">)</span>\n    <span class=\"n\">inst</span><span class=\"p\">.</span><span class=\"nf\">fields</span> <span class=\"o\">=</span> <span class=\"vi\">@fields</span><span class=\"p\">.</span><span class=\"nf\">merge</span><span class=\"p\">(</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">inst</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"error":{"source":"source","definition":{"type":"def","name":"error","args":[{"type":"arg","name":"msg"},{"type":"optarg","name":"error","value_type":"nil","value":"nil"},{"type":"kwrestarg","name":"fields"}],"doc":{"doc_visibility_annotation":"public","type":"def","contents":[{"type":"text_block","contents":" Emits an error to the log output. When error is provided, this\nmethod attempts to gather a stacktrace to include in the emitted entry."}]},"visibility":"public","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":105,"end_at":110,"source":"  def error(msg, error = nil, **fields)\n    return if LEVELS[@level] > LEVELS[:error]\n\n    wrap(:error, msg, error, fields)\n    nil\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">error</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"kp\">nil</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"k\">if</span> <span class=\"no\">LEVELS</span><span class=\"p\">[</span><span class=\"vi\">@level</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"no\">LEVELS</span><span class=\"p\">[</span><span class=\"ss\">:error</span><span class=\"p\">]</span>\n\n    <span class=\"n\">wrap</span><span class=\"p\">(</span><span class=\"ss\">:error</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"kp\">nil</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"fatal":{"source":"source","definition":{"type":"def","name":"fatal","args":[{"type":"arg","name":"msg"},{"type":"optarg","name":"error","value_type":"nil","value":"nil"},{"type":"kwrestarg","name":"fields"}],"doc":{"doc_visibility_annotation":"public","type":"def","contents":[{"type":"text_block","contents":[{"type":"span","contents":" Emits a fatal message to the log output, and invokes "},{"type":"ref","ref_type":"method","name":"exit","target":"Kernel","class_path":null,"contents":"Kernel#exit"},{"type":"span","contents":"with a non-zero status code. When error is provided, this method attempts\nto gather a stacktrace to include in the emitted entry. This log entry\ncannot be filtered, and is always emitted."}]}]},"visibility":"public","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":116,"end_at":119,"source":"  def fatal(msg, error = nil, **fields)\n    wrap(:fatal, msg, error, fields)\n    exit 1\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">fatal</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"kp\">nil</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">wrap</span><span class=\"p\">(</span><span class=\"ss\">:fatal</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"nb\">exit</span> <span class=\"mi\">1</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"dump":{"source":"source","definition":{"type":"def","name":"dump","args":[{"type":"arg","name":"log"},{"type":"optarg","name":"data","value_type":"nil","value":"nil"},{"type":"kwrestarg","name":"fields"}],"doc":{"doc_visibility_annotation":"public","type":"def","contents":[{"type":"text_block","contents":" Dumps a given String or Array in the same format as <code>hexdump -C</code>."}]},"visibility":"public","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":122,"end_at":143,"source":"  def dump(log, data = nil, **fields)\n    return if LEVELS[@level] > LEVELS[:debug]\n\n    if data.nil?\n      data = log\n      log = nil\n    end\n\n    data = data.pack(\"C*\") if data.is_a? Array\n    dump = []\n    padding = @format == :json ? \"\" : \"        \"\n    Hexdump.dump(data, output: dump)\n    dump.map! { |line| \"#{padding}#{line.chomp}\" }\n    dump = dump.join(\"\\n\")\n\n    if @format == :json\n      fields[:dump] = dump\n      dump = nil\n    end\n    wrap(:dump, log || \"\", nil, fields)\n    write_output(\"#{dump}\\n\\n\") unless dump.nil?\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">dump</span><span class=\"p\">(</span><span class=\"n\">log</span><span class=\"p\">,</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"kp\">nil</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"k\">if</span> <span class=\"no\">LEVELS</span><span class=\"p\">[</span><span class=\"vi\">@level</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"no\">LEVELS</span><span class=\"p\">[</span><span class=\"ss\">:debug</span><span class=\"p\">]</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">data</span><span class=\"p\">.</span><span class=\"nf\">nil?</span>\n      <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">log</span>\n      <span class=\"n\">log</span> <span class=\"o\">=</span> <span class=\"kp\">nil</span>\n    <span class=\"k\">end</span>\n\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"p\">.</span><span class=\"nf\">pack</span><span class=\"p\">(</span><span class=\"s2\">\"C*\"</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">data</span><span class=\"p\">.</span><span class=\"nf\">is_a?</span> <span class=\"no\">Array</span>\n    <span class=\"n\">dump</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"n\">padding</span> <span class=\"o\">=</span> <span class=\"vi\">@format</span> <span class=\"o\">==</span> <span class=\"ss\">:json</span> <span class=\"p\">?</span> <span class=\"s2\">\"\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"        \"</span>\n    <span class=\"no\">Hexdump</span><span class=\"p\">.</span><span class=\"nf\">dump</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"ss\">output: </span><span class=\"n\">dump</span><span class=\"p\">)</span>\n    <span class=\"n\">dump</span><span class=\"p\">.</span><span class=\"nf\">map!</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">line</span><span class=\"o\">|</span> <span class=\"s2\">\"</span><span class=\"si\">#{</span><span class=\"n\">padding</span><span class=\"si\">}#{</span><span class=\"n\">line</span><span class=\"p\">.</span><span class=\"nf\">chomp</span><span class=\"si\">}</span><span class=\"s2\">\"</span> <span class=\"p\">}</span>\n    <span class=\"n\">dump</span> <span class=\"o\">=</span> <span class=\"n\">dump</span><span class=\"p\">.</span><span class=\"nf\">join</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"vi\">@format</span> <span class=\"o\">==</span> <span class=\"ss\">:json</span>\n      <span class=\"n\">fields</span><span class=\"p\">[</span><span class=\"ss\">:dump</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">dump</span>\n      <span class=\"n\">dump</span> <span class=\"o\">=</span> <span class=\"kp\">nil</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">wrap</span><span class=\"p\">(</span><span class=\"ss\">:dump</span><span class=\"p\">,</span> <span class=\"n\">log</span> <span class=\"o\">||</span> <span class=\"s2\">\"\"</span><span class=\"p\">,</span> <span class=\"kp\">nil</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"si\">#{</span><span class=\"n\">dump</span><span class=\"si\">}</span><span class=\"se\">\\n\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span> <span class=\"k\">unless</span> <span class=\"n\">dump</span><span class=\"p\">.</span><span class=\"nf\">nil?</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"color":{"source":"source","definition":{"type":"def","name":"color","args":[{"type":"arg","name":"color"},{"type":"arg","name":"text"}],"doc":{"doc_visibility_annotation":"internal","type":"def","contents":[{"type":"text_block","contents":" Formats a given text using the ANSI escape sequences. Notice\nthat this method does not attempt to determine whether the current output\nsupports escape sequences."}]},"visibility":"private","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":150,"end_at":158,"source":"  def color(color, text)\n    bg = BACKGROUNDS[color]\n    reset_bg = \"\"\n    if bg\n      bg = \"\\e[#{bg}m\"\n      reset_bg = \"\\e[49m\"\n    end\n    \"#{bg}\\e[#{COLORS[color]}m#{text}\\e[#{COLORS[:reset]}m#{reset_bg}\"\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">color</span><span class=\"p\">(</span><span class=\"n\">color</span><span class=\"p\">,</span> <span class=\"n\">text</span><span class=\"p\">)</span>\n    <span class=\"n\">bg</span> <span class=\"o\">=</span> <span class=\"no\">BACKGROUNDS</span><span class=\"p\">[</span><span class=\"n\">color</span><span class=\"p\">]</span>\n    <span class=\"n\">reset_bg</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"</span>\n    <span class=\"k\">if</span> <span class=\"n\">bg</span>\n      <span class=\"n\">bg</span> <span class=\"o\">=</span> <span class=\"s2\">\"</span><span class=\"se\">\\e</span><span class=\"s2\">[</span><span class=\"si\">#{</span><span class=\"n\">bg</span><span class=\"si\">}</span><span class=\"s2\">m\"</span>\n      <span class=\"n\">reset_bg</span> <span class=\"o\">=</span> <span class=\"s2\">\"</span><span class=\"se\">\\e</span><span class=\"s2\">[49m\"</span>\n    <span class=\"k\">end</span>\n    <span class=\"s2\">\"</span><span class=\"si\">#{</span><span class=\"n\">bg</span><span class=\"si\">}</span><span class=\"se\">\\e</span><span class=\"s2\">[</span><span class=\"si\">#{</span><span class=\"no\">COLORS</span><span class=\"p\">[</span><span class=\"n\">color</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s2\">m</span><span class=\"si\">#{</span><span class=\"n\">text</span><span class=\"si\">}</span><span class=\"se\">\\e</span><span class=\"s2\">[</span><span class=\"si\">#{</span><span class=\"no\">COLORS</span><span class=\"p\">[</span><span class=\"ss\">:reset</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s2\">m</span><span class=\"si\">#{</span><span class=\"n\">reset_bg</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"clean_caller_locations":{"source":"source","definition":{"type":"def","name":"clean_caller_locations","args":[],"doc":{"doc_visibility_annotation":"internal","type":"def","contents":[{"type":"text_block","contents":" Removes all backtrace frames pointing to the logging facility\nitself."}]},"visibility":"private","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":162,"end_at":164,"source":"  def clean_caller_locations\n    caller_locations.reject { |t| t.absolute_path&.end_with?(\"logrb.rb\") }\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">clean_caller_locations</span>\n    <span class=\"n\">caller_locations</span><span class=\"p\">.</span><span class=\"nf\">reject</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">t</span><span class=\"o\">|</span> <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">absolute_path</span><span class=\"o\">&amp;</span><span class=\"p\">.</span><span class=\"nf\">end_with?</span><span class=\"p\">(</span><span class=\"s2\">\"logrb.rb\"</span><span class=\"p\">)</span> <span class=\"p\">}</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"determine_caller":{"source":"source","definition":{"type":"def","name":"determine_caller","args":[],"doc":{"doc_visibility_annotation":"internal","type":"def","contents":[{"type":"text_block","contents":" Returns the caller of a function, returning a pair containing\nits path and base method name."}]},"visibility":"private","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":168,"end_at":171,"source":"  def determine_caller\n    c = clean_caller_locations.first\n    [normalize_location(c), c.base_label]\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">determine_caller</span>\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">clean_caller_locations</span><span class=\"p\">.</span><span class=\"nf\">first</span>\n    <span class=\"p\">[</span><span class=\"n\">normalize_location</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">),</span> <span class=\"n\">c</span><span class=\"p\">.</span><span class=\"nf\">base_label</span><span class=\"p\">]</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"normalize_location":{"source":"source","definition":{"type":"def","name":"normalize_location","args":[{"type":"arg","name":"trace"},{"type":"kwoptarg","name":"include_function_name","value_type":"bool","value":false}],"doc":{"doc_visibility_annotation":"internal","type":"def","contents":[{"type":"text_block","contents":" Performs a cleanup for a given backtrace frame."},{"type":"field_block","contents":{"trace":{"type":"text_block","contents":"Trace to be clean."},"include_function_name":{"type":"text_block","contents":"Optional. When true, includes the function name on the normalized string. Defaults to false."}}}]},"visibility":"private","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":178,"end_at":186,"source":"  def normalize_location(trace, include_function_name: false)\n    path = trace.absolute_path\n    return trace.to_s if path.nil?\n\n    if (root = Gem.path.find { |p| path.start_with?(p) })\n      path = \"$GEM_PATH#{path[root.length..]}\"\n    end\n    \"#{path}:#{trace.lineno}#{include_function_name ? \" in `#{trace.label}'\" : \"\"}\"\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">normalize_location</span><span class=\"p\">(</span><span class=\"n\">trace</span><span class=\"p\">,</span> <span class=\"ss\">include_function_name: </span><span class=\"kp\">false</span><span class=\"p\">)</span>\n    <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"n\">trace</span><span class=\"p\">.</span><span class=\"nf\">absolute_path</span>\n    <span class=\"k\">return</span> <span class=\"n\">trace</span><span class=\"p\">.</span><span class=\"nf\">to_s</span> <span class=\"k\">if</span> <span class=\"n\">path</span><span class=\"p\">.</span><span class=\"nf\">nil?</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"no\">Gem</span><span class=\"p\">.</span><span class=\"nf\">path</span><span class=\"p\">.</span><span class=\"nf\">find</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"nb\">p</span><span class=\"o\">|</span> <span class=\"n\">path</span><span class=\"p\">.</span><span class=\"nf\">start_with?</span><span class=\"p\">(</span><span class=\"nb\">p</span><span class=\"p\">)</span> <span class=\"p\">})</span>\n      <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"s2\">\"$GEM_PATH</span><span class=\"si\">#{</span><span class=\"n\">path</span><span class=\"p\">[</span><span class=\"n\">root</span><span class=\"p\">.</span><span class=\"nf\">length</span><span class=\"o\">..</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n    <span class=\"k\">end</span>\n    <span class=\"s2\">\"</span><span class=\"si\">#{</span><span class=\"n\">path</span><span class=\"si\">}</span><span class=\"s2\">:</span><span class=\"si\">#{</span><span class=\"n\">trace</span><span class=\"p\">.</span><span class=\"nf\">lineno</span><span class=\"si\">}#{</span><span class=\"n\">include_function_name</span> <span class=\"p\">?</span> <span class=\"s2\">\" in `</span><span class=\"si\">#{</span><span class=\"n\">trace</span><span class=\"p\">.</span><span class=\"nf\">label</span><span class=\"si\">}</span><span class=\"s2\">'\"</span> <span class=\"p\">:</span> <span class=\"s2\">\"\"</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"stack_trace":{"source":"source","definition":{"type":"def","name":"stack_trace","args":[{"type":"optarg","name":"trace","value_type":"send","value":{"target":[],"name":"clean_caller_locations"}}],"doc":{"doc_visibility_annotation":"internal","type":"def","contents":[{"type":"text_block","contents":" Returns a string containing a stacktrace of the current\ninvocation."}]},"visibility":"private","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":190,"end_at":192,"source":"  def stack_trace(trace = clean_caller_locations)\n    trace.map { |s| normalize_location(s, include_function_name: true) }.join(\"\\n\")\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">stack_trace</span><span class=\"p\">(</span><span class=\"n\">trace</span> <span class=\"o\">=</span> <span class=\"n\">clean_caller_locations</span><span class=\"p\">)</span>\n    <span class=\"n\">trace</span><span class=\"p\">.</span><span class=\"nf\">map</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">s</span><span class=\"o\">|</span> <span class=\"n\">normalize_location</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"ss\">include_function_name: </span><span class=\"kp\">true</span><span class=\"p\">)</span> <span class=\"p\">}.</span><span class=\"nf\">join</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"compose_line":{"source":"source","definition":{"type":"def","name":"compose_line","args":[{"type":"arg","name":"level"},{"type":"arg","name":"caller_meta"},{"type":"arg","name":"msg"},{"type":"arg","name":"fields"}],"doc":{"doc_visibility_annotation":"internal","type":"def","contents":[{"type":"text_block","contents":" Composes a log line with given information."},{"type":"field_block","contents":{"level":{"type":"text_block","contents":"The severity of the log message"},"caller_meta":{"type":"text_block","contents":"An Array containing the caller&#39;s location and name"},"msg":{"type":"text_block","contents":"The message to be logged"},"fields":{"type":"text_block","contents":"A Hash of fields to be included in the entry"}}}]},"visibility":"private","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":200,"end_at":210,"source":"  def compose_line(level, caller_meta, msg, fields)\n    ts = Time.now.strftime(\"%Y-%m-%dT%H:%M:%S.%L%z\")\n    msg = \" #{msg}\" unless msg.empty?\n    fields_str = if fields.empty?\n                   \"\"\n                 else\n                   \" #{fields}\"\n                 end\n    level_str = color(level, level.to_s.upcase)\n    \"#{ts} #{level_str}: #{caller_meta.last}:#{msg}#{fields_str}\"\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">compose_line</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">caller_meta</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">ts</span> <span class=\"o\">=</span> <span class=\"no\">Time</span><span class=\"p\">.</span><span class=\"nf\">now</span><span class=\"p\">.</span><span class=\"nf\">strftime</span><span class=\"p\">(</span><span class=\"s2\">\"%Y-%m-%dT%H:%M:%S.%L%z\"</span><span class=\"p\">)</span>\n    <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">\" </span><span class=\"si\">#{</span><span class=\"n\">msg</span><span class=\"si\">}</span><span class=\"s2\">\"</span> <span class=\"k\">unless</span> <span class=\"n\">msg</span><span class=\"p\">.</span><span class=\"nf\">empty?</span>\n    <span class=\"n\">fields_str</span> <span class=\"o\">=</span> <span class=\"k\">if</span> <span class=\"n\">fields</span><span class=\"p\">.</span><span class=\"nf\">empty?</span>\n                   <span class=\"s2\">\"\"</span>\n                 <span class=\"k\">else</span>\n                   <span class=\"s2\">\" </span><span class=\"si\">#{</span><span class=\"n\">fields</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n                 <span class=\"k\">end</span>\n    <span class=\"n\">level_str</span> <span class=\"o\">=</span> <span class=\"n\">color</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">level</span><span class=\"p\">.</span><span class=\"nf\">to_s</span><span class=\"p\">.</span><span class=\"nf\">upcase</span><span class=\"p\">)</span>\n    <span class=\"s2\">\"</span><span class=\"si\">#{</span><span class=\"n\">ts</span><span class=\"si\">}</span><span class=\"s2\"> </span><span class=\"si\">#{</span><span class=\"n\">level_str</span><span class=\"si\">}</span><span class=\"s2\">: </span><span class=\"si\">#{</span><span class=\"n\">caller_meta</span><span class=\"p\">.</span><span class=\"nf\">last</span><span class=\"si\">}</span><span class=\"s2\">:</span><span class=\"si\">#{</span><span class=\"n\">msg</span><span class=\"si\">}#{</span><span class=\"n\">fields_str</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"text":{"source":"source","definition":{"type":"def","name":"text","args":[{"type":"arg","name":"level"},{"type":"arg","name":"msg"},{"type":"arg","name":"error"},{"type":"arg","name":"fields"},{"type":"arg","name":"caller_meta"}],"doc":{"doc_visibility_annotation":"internal","type":"def","contents":[{"type":"text_block","contents":" Logs a text entry to the current output."},{"type":"field_block","contents":{"level":{"type":"text_block","contents":"The severity of the message to be logged."},"msg":{"type":"text_block","contents":"The message to be logged"},"error":{"type":"text_block","contents":"Either an Exception object or nil. This parameter is used to provide extra information on the logged entry."},"fields":{"type":"text_block","contents":"A Hash containing metadata to be included in the logged entry."},"caller_meta":{"type":"text_block","contents":"An Array containing the caller&#39;s location and name."}}}]},"visibility":"private","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":221,"end_at":236,"source":"  def text(level, msg, error, fields, caller_meta)\n    fields ||= {}\n    fields.merge! @fields\n    write_output(compose_line(level, caller_meta, msg, fields))\n    if (error_message = error&.message)\n      write_output(\": #{error_message}\")\n    end\n    write_output(\"\\n\")\n    return unless level == :error\n\n    backtrace_str = backtrace(error)\n                    .split(\"\\n\")\n                    .map { |s| \"        #{s}\" }.join(\"\\n\")\n    write_output(backtrace_str)\n    write_output(\"\\n\")\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">text</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">,</span> <span class=\"n\">caller_meta</span><span class=\"p\">)</span>\n    <span class=\"n\">fields</span> <span class=\"o\">||=</span> <span class=\"p\">{}</span>\n    <span class=\"n\">fields</span><span class=\"p\">.</span><span class=\"nf\">merge!</span> <span class=\"vi\">@fields</span>\n    <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"n\">compose_line</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">caller_meta</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">))</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">error_message</span> <span class=\"o\">=</span> <span class=\"n\">error</span><span class=\"o\">&amp;</span><span class=\"p\">.</span><span class=\"nf\">message</span><span class=\"p\">)</span>\n      <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"s2\">\": </span><span class=\"si\">#{</span><span class=\"n\">error_message</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"k\">unless</span> <span class=\"n\">level</span> <span class=\"o\">==</span> <span class=\"ss\">:error</span>\n\n    <span class=\"n\">backtrace_str</span> <span class=\"o\">=</span> <span class=\"n\">backtrace</span><span class=\"p\">(</span><span class=\"n\">error</span><span class=\"p\">)</span>\n                    <span class=\"p\">.</span><span class=\"nf\">split</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n                    <span class=\"p\">.</span><span class=\"nf\">map</span> <span class=\"p\">{</span> <span class=\"o\">|</span><span class=\"n\">s</span><span class=\"o\">|</span> <span class=\"s2\">\"        </span><span class=\"si\">#{</span><span class=\"n\">s</span><span class=\"si\">}</span><span class=\"s2\">\"</span> <span class=\"p\">}.</span><span class=\"nf\">join</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"n\">backtrace_str</span><span class=\"p\">)</span>\n    <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"backtrace":{"source":"source","definition":{"type":"def","name":"backtrace","args":[{"type":"arg","name":"from"}],"doc":{"doc_visibility_annotation":"internal","type":"def","contents":[{"type":"text_block","contents":[{"type":"span","contents":" Attempts to obtain a backtrace from a provided object. In case\nthe object does not include backtrace metadata, uses "},{"type":"ref","ref_type":"method","name":"stack_trace","target":null,"class_path":null,"contents":"#stack_trace","ref_path":["Logrb","stack_trace"]},{"type":"span","contents":" as a\nfallback."}]}]},"visibility":"private","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":241,"end_at":247,"source":"  def backtrace(from)\n    if from.respond_to?(:backtrace_locations) && !from.backtrace_locations.nil?\n      stack_trace(from.backtrace_locations)\n    else\n      stack_trace\n    end\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">backtrace</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">from</span><span class=\"p\">.</span><span class=\"nf\">respond_to?</span><span class=\"p\">(</span><span class=\"ss\">:backtrace_locations</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">from</span><span class=\"p\">.</span><span class=\"nf\">backtrace_locations</span><span class=\"p\">.</span><span class=\"nf\">nil?</span>\n      <span class=\"n\">stack_trace</span><span class=\"p\">(</span><span class=\"n\">from</span><span class=\"p\">.</span><span class=\"nf\">backtrace_locations</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">stack_trace</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"write_output":{"source":"source","definition":{"type":"def","name":"write_output","args":[{"type":"arg","name":"text"}],"doc":{"doc_visibility_annotation":"internal","type":"def","contents":[{"type":"text_block","contents":" Writes a given value to the current&#39;s output IO. Calls to this\nmethod are thread-safe."}]},"visibility":"private","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":251,"end_at":255,"source":"  def write_output(text)\n    Logrb.mutex.synchronize do\n      @output.write(text)\n    end\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">write_output</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n    <span class=\"no\">Logrb</span><span class=\"p\">.</span><span class=\"nf\">mutex</span><span class=\"p\">.</span><span class=\"nf\">synchronize</span> <span class=\"k\">do</span>\n      <span class=\"vi\">@output</span><span class=\"p\">.</span><span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"json":{"source":"source","definition":{"type":"def","name":"json","args":[{"type":"arg","name":"level"},{"type":"arg","name":"msg"},{"type":"arg","name":"error"},{"type":"arg","name":"fields"},{"type":"arg","name":"caller_meta"}],"doc":{"doc_visibility_annotation":"internal","type":"def","contents":[{"type":"text_block","contents":" Logs a JSON entry to the current output."},{"type":"field_block","contents":{"level":{"type":"text_block","contents":"The severity of the message to be logged."},"msg":{"type":"text_block","contents":"The message to be logged"},"error":{"type":"text_block","contents":"Either an Exception object or nil. This parameter is used to provide extra information on the logged entry."},"fields":{"type":"text_block","contents":"A Hash containing metadata to be included in the logged entry."},"caller_meta":{"type":"text_block","contents":"An Array containing the caller&#39;s location and name."}}}]},"visibility":"private","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":266,"end_at":280,"source":"  def json(level, msg, error, fields, caller_meta)\n    fields ||= {}\n    fields.merge! @fields\n    data = {\n      level: level,\n      caller: caller_meta.first,\n      msg: msg,\n      ts: Time.now.utc.to_i\n    }\n\n    data[:stacktrace] = backtrace(error) if level == :error\n\n    data.merge!(fields)\n    write_output(\"#{data.to_json}\\n\")\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">json</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">,</span> <span class=\"n\">caller_meta</span><span class=\"p\">)</span>\n    <span class=\"n\">fields</span> <span class=\"o\">||=</span> <span class=\"p\">{}</span>\n    <span class=\"n\">fields</span><span class=\"p\">.</span><span class=\"nf\">merge!</span> <span class=\"vi\">@fields</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n      <span class=\"ss\">level: </span><span class=\"n\">level</span><span class=\"p\">,</span>\n      <span class=\"ss\">caller: </span><span class=\"n\">caller_meta</span><span class=\"p\">.</span><span class=\"nf\">first</span><span class=\"p\">,</span>\n      <span class=\"ss\">msg: </span><span class=\"n\">msg</span><span class=\"p\">,</span>\n      <span class=\"ss\">ts: </span><span class=\"no\">Time</span><span class=\"p\">.</span><span class=\"nf\">now</span><span class=\"p\">.</span><span class=\"nf\">utc</span><span class=\"p\">.</span><span class=\"nf\">to_i</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"ss\">:stacktrace</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">backtrace</span><span class=\"p\">(</span><span class=\"n\">error</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">level</span> <span class=\"o\">==</span> <span class=\"ss\">:error</span>\n\n    <span class=\"n\">data</span><span class=\"p\">.</span><span class=\"nf\">merge!</span><span class=\"p\">(</span><span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">write_output</span><span class=\"p\">(</span><span class=\"s2\">\"</span><span class=\"si\">#{</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"nf\">to_json</span><span class=\"si\">}</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null},"wrap":{"source":"source","definition":{"type":"def","name":"wrap","args":[{"type":"arg","name":"level"},{"type":"arg","name":"msg"},{"type":"arg","name":"error"},{"type":"arg","name":"fields"}],"doc":{"doc_visibility_annotation":"internal","type":"def","contents":[{"type":"text_block","contents":[{"type":"span","contents":" Dynamically invokes the current log formatter for the\nprovided arguments. For further information, see "},{"type":"ref","ref_type":"method","name":"text","target":null,"class_path":null,"contents":"#text","ref_path":["Logrb","text"]},{"type":"span","contents":" and "},{"type":"ref","ref_type":"method","name":"json","target":null,"class_path":null,"contents":"#json","ref_path":["Logrb","json"]}]}]},"visibility":"private","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":284,"end_at":288,"source":"  def wrap(level, msg, error, fields)\n    msg = msg.to_s\n    send(@format, level, msg, error, fields, determine_caller)\n    exit 1 if level == :fatal\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nf\">wrap</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"n\">msg</span><span class=\"p\">.</span><span class=\"nf\">to_s</span>\n    <span class=\"nb\">send</span><span class=\"p\">(</span><span class=\"vi\">@format</span><span class=\"p\">,</span> <span class=\"n\">level</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">,</span> <span class=\"n\">determine_caller</span><span class=\"p\">)</span>\n    <span class=\"nb\">exit</span> <span class=\"mi\">1</span> <span class=\"k\">if</span> <span class=\"n\">level</span> <span class=\"o\">==</span> <span class=\"ss\">:fatal</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null}},"sdefs":{"mutex":{"source":"source","definition":{"type":"defs","name":"mutex","args":[],"doc":{"doc_visibility_annotation":"internal","type":"defs","contents":[{"type":"text_block","contents":" A mutex instance used for synchronizing the usage of the output\nIO."}]},"visibility":"public","overriden_by":null,"defined_by":{"filename":"/work/lib/logrb.rb","start_at":65,"end_at":67,"source":"  def self.mutex\n    @mutex ||= Mutex.new\n  end","markdown_source":"<div class=\"highlight\"><pre class=\"highlight ruby\"><code>  <span class=\"k\">def</span> <span class=\"nc\">self</span><span class=\"o\">.</span><span class=\"nf\">mutex</span>\n    <span class=\"vi\">@mutex</span> <span class=\"o\">||=</span> <span class=\"no\">Mutex</span><span class=\"p\">.</span><span class=\"nf\">new</span>\n  <span class=\"k\">end</span>\n</code></pre></div>"}},"overriding":null}},"classes":[],"modules":[],"includes":[],"extends":[],"inherits":null,"attributes":{"fields":{"source":"source","definition":{"defined_by":["/work/lib/logrb.rb"],"name":"fields","docs":null,"type":"accessor","writer_visibility":"public","reader_visibility":"public"},"overriding":null},"level":{"source":"source","definition":{"defined_by":["/work/lib/logrb.rb"],"name":"level","docs":null,"type":"accessor","writer_visibility":"public","reader_visibility":"public"},"overriding":null},"format":{"source":"source","definition":{"defined_by":["/work/lib/logrb.rb"],"name":"format","docs":null,"type":"accessor","writer_visibility":"public","reader_visibility":"public"},"overriding":null}}},"path":["Logrb"]},"__N_SSG":true}